
import java.io.IOException;
import java.util.Calendar;
import java.util.LinkedHashMap;
import flanagan.*;
import flanagan.analysis.Stat;

public class security {
	private String securitySymbol;
	private double dailyVolatility;
	private double VaR;
	private double EWMAVolatility;
	private LinkedHashMap<Calendar, prices> historicalPrices;
	private int quantity;

	public security(String securitySymbol, int quantity) throws IOException {
		this.securitySymbol = securitySymbol;
		this.quantity = quantity;
		this.historicalPrices = new LinkedHashMap<Calendar, prices>();
		loadData();
		calcDailyVolatility();
		calcDailyVolatilityEWMA();
		
	}

	public double getVaR() {
		return this.VaR;
	}

	public String getSymbol() {
		return this.securitySymbol;
	}

	public int getQuantity() {
		return this.quantity;
	}

	public double getDailyVolatility() {
		return this.dailyVolatility;
	}

	public double getAnnualVolatility() {
		return this.dailyVolatility * Math.sqrt(252);
	}

	public double getEWMAVolatility() {
		return this.EWMAVolatility;
	}

	protected void calcDailyVolatility() {
		System.out.println("Calculating volatility..");
		this.dailyVolatility = Utilities.calcDailyVolatilityRet(this.historicalPrices);
		System.out.println("Complete.");
	}

	public double getClosePriceForDate(Calendar date) {
		return this.historicalPrices.get(date).getClose();
	}

	public double getOpenPriceForDate(Calendar date) {
		return this.historicalPrices.get(date).getOpen();
	}

	protected void loadData() throws IOException {
		this.historicalPrices = Utilities.DLData(this.securitySymbol);
	}

	public double calcVaRVariCov(int confLevel, int period) {
		return Stat.gaussianInverseCDF(confLevel) * this.dailyVolatility * Math.sqrt(period); // Z-score, how
																	// to
																	// calculate
																	// from user
																	// input?
	}

	protected void calcDailyVolatilityEWMA() {
		this.EWMAVolatility = Utilities.calcDailyVolatilityEWMA(this.historicalPrices);
	}
	

}
